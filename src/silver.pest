WHITESPACE = {" " | "\t" | "\n" }

char = { 'a'..'z' | 'A'..'Z' | "$" | "_"}
num = { '0'..'9' }

integer = {num+}

// Identifiers
ident = { (char ) ~ (char | num | "'" )* }

// Types
// type ::=
// "Int" | "Bool" | "Perm" | "Ref" | "Rational" | // primitive types
// "Seq" "[" type "]" |                           // sequence type
// "Set" "[" type "]" |                           // set type
// "Multiset" "[" type "]" |                      // multiset type
// ident [ "[" type^,* "]" ]                      // [instance of a generic] domain type

type = { "Int" | "Bool" | "Perm" | "Ref" | "Rational"
       | "Seq" ~ "[" ~ type ~ "]"
       | "Set" ~ "[" ~ type ~ "]"
       | "Multiset" ~ "[" ~ type ~ "]"
       | ident ~ "[" ~ type ~ ("," ~ type)* ~ "]" // ???? domain type
     }

// predicate-access ::=
//   ident "(" exp^,* ")"         // predicate access
predicate_access = { ident ~ "(" ~ exp ~ ("," ~ exp)* ~ ")" }

// field-access ::=
//   exp "." ident |              // field access
field_access = { exp~"."~ident }
// loc-access ::=
//   field-access | predicate-access
loc_access = {field_access | predicate_access }
// acc-exp ::=
//    "acc" "(" loc-access ["," exp ]")" //access
                                // default is write
acc_exp = { "acc"~"("~loc_access~(","~exp)?~")" }
// trigger ::=
//   "{" exp^,* "}"  // a trigger for a quantification
trigger = {
       "{"~exp~(","~exp)~"}"
}
// seq-op-exp ::=
//   exp "[" exp "]"          |  // sequence lookup
//   exp "[" ".." exp "]"     |  // take n first elements
//   exp "[" exp ".." "]"     |  // drop n first elements
//   exp "[" exp ".." exp "]" |  // take and drop
//   exp "[" exp ":=" exp "]" |  // update sequence at
seq_op_exp = {
       exp ~ "[" ~ exp ~ "]" |
       exp ~ "[" ~ ".." ~ exp ~ "]" |
       exp ~ "[" ~ exp ~ ".." ~ "]" |
       exp ~ "[" ~ exp ~ ".." ~ exp ~ "]" |
       exp ~ "[" ~ exp ~ ":=" ~ exp ~ "]"
}

// set-constructor-exp ::=
//   "Set" "[" type "]" "(" ")"             | // empty set
//   "Set" "(" exp^,* ")"                   | // explicit set
//   "Multiset" "[" type "]" "(" ")"        | // empty multiset
//   "Multiset" "(" exp^,* ")"              | // explicit multiset
set_constructor_exp = {
       "Set" ~ "[" ~ type ~ "]" ~ "(" ~ ")" |
       "Set" ~ "(" ~ exp ~ ("," ~ exp)* ~ ")" |
       "Multiset" ~ "[" ~ type ~ "]" ~ "(" ~ ")" |
       "Multiset" ~ "(" ~ exp ~ ("," ~ exp)* ~ ")"
}

// seq-constructor-exp ::=
//   "Seq[" type "]()"     | // the empty sequence
//   "Seq(" exp^,* ")"     | // explicit sequence (must not be empty)
//   "[" exp ".." exp ")"    // half-open range of numbers
seq_constructor_exp = {
       "Seq[" ~ type ~ "]()" |
       "Seq(" ~ exp ~ ("," ~ exp)* ~ ")" |
       "[" ~ exp ~ ".." ~ exp ~ ")"
}

// forperm-exp ::=
//     "forperm" "[" ident^,* "]" ident "::" exp
forperm_exp = {
       "forperm" ~ "[" ~ ident ~ ("," ~ ident)* ~ "]" ~ ident ~ "::" ~ exp
}
// let-in-exp ::=
//     "let" ident "==" "(" exp ")" "in" exp
let_in_exp = {
       "let" ~ ident ~ "==" ~ "(" ~ exp ~ ")" ~ "in" ~ exp
}
// magic-wand-exp ::=
//     exp // except that it must not be <==> or ==>
magic_wand_exp = { // TODO: Ban <==> or ==>
       exp
}
// exp ::=
//   "true"  | "false" |          // boolean literal
//   integer |                    // integer literal
//   "null"   |                   // null literal
//   "result" |                   // result literal in
//                                //  function postconditions
//   ident    |                   // local variable read

//   "(" exp ")" |

//   unop exp |                  // unary expression
//   exp binop exp |             // binary expression
//   exp "?" exp ":" exp |       // conditional expression

//   "old" "(" exp ")"           // old expression
//   "[" ident "]" "(" exp ")"   // labeled old expression
//   "lhs" "(" exp ")"           // apply old expression

//   "none"     |             // no permission literal
//   "write"    |             // full permission literal
//   "epsilon"  |             // epsilon permission literal
//   "wildcard" |             // wildcard permission

//   "perm" "(" loc-access ")" | // current permission
//                               //  of given location

//   acc-exp  |                   // accessibility predicate

//   ident "(" exp^,* ")" |                // [domain] function application
//   "(" ident "(" exp^,* ")" ":" type ")" // typed function application

//   field-access         |  // field read
//   predicate-access     |  // predicate access

//   "[" exp "," exp "]" |        // inhale exhale expression
//   "unfolding" acc-exp "in" exp | // unfolding expression
//   "folding" acc-exp "in" exp
//   "applying" ( "(" magic-wand-exp ")" | ident ) "in" exp
//   "packaging" ( "(" magic-wand-exp ")" | ident ) "in" exp

//   // quantification
//   "forall" formal-arg^,* "::" trigger^,* exp |
//   "exists" formal-arg^,* "::" exp |

//   seq-constructor-exp      |
//   set-constructor-exp      |

//   seq-op-exp  |
//   "|" exp "|" |                // length of a sequence; or set/multiset cardinality

//   let-in-exp  |
//   forperm-exp
exp_atom = {
       "true" | "false"
      | integer
      | "null"
      | "result"
      | ident
      | "("~ exp ~ ")"
      | unop~exp
      | "old"~"("~exp~")"
      | "["~ident~"]"~"("~exp~")"
      | "lhs"~"("~exp~")"
      | "none"
      | "write"
      | "epsilon"
      | "wildcard"
      | "perm"~"("~loc_access~")"
      | ident~"("~exp~(","~exp)*~")"
      | "("~ident~"("~exp~(","~exp)*~")"~":"~type~")"
      // | field_access
       | predicate_access
       | "["~exp~","~exp~"]"
       | "unfolding"~acc_exp~"in"~exp
       | "folding"~acc_exp~"in"~exp
       | "applying"~"("~magic_wand_exp~")"~"in"~exp
       | "packaging"~"("~magic_wand_exp~")"~"in"~exp
       | "forall"~formal_arg~(","~formal_arg)*~"::"~trigger~(","~trigger)*~exp
       | "exists"~formal_arg~(","~formal_arg)*~"::"~exp
       | seq_constructor_exp
       | set_constructor_exp
       // | seq_op_exp
       | "|"~exp~"|"
       | let_in_exp
       | forperm_exp

}
exp = {exp_atom~(binop_plus~exp_atom)*
}

binop_plus = _{ binop | "?"~exp~":" }

single_exp = _{ SOI~exp~EOI }
// exp = { "true" | "false"
//       | integer
//       | "null"
//       | "result"
//       | ident
//       | "("~ exp ~ ")"
//       | unop~exp
//       | exp~binop~exp
//       | exp~"?"~exp~":"~exp
//       | "old"~"("~exp~")"
//       | "["~ident~"]"~"("~exp~")"
//       | "lhs"~"("~exp~")"
//       | "none"
//       | "write"
//       | "epsilon"
//       | "wildcard"
//       | "perm"~"("~loc_access~")"
//       | acc_exp
//       | ident~"("~exp~(","~exp)*~")"
//       | "("~ident~"("~exp~(","~exp)*~")"~":"~type~")"
// }

// binop ::=
//   "==" | "!=" |                  // equality operators
//   "==>" | "||" | "&&" |"<==>" |  // boolean operators
//   "<" | "<=" | ">" | ">=" |      // ordering
//                                  //  (integers and permissions)
//   "+" | "-" | "*" |              // arithmetic operators
//                                  //  (integers and permissions)
//                                  // also int*permission
//   "\\" | "\%" |                  // arithmetic division
//                                  //  and modulo
//   "\/" |                         // permission division
//                                  //  (of two integers)
//   "--*" |                        // magic wand

//   "union" | "intersection" | "setminus"  //set operators
//   "++"  |           // sequence concatenation
//   "in"  |           // set/multiset/sequence membership
//   "subset"          // subset relation
binop = {
| eq | neq
| implies | or | and | iff
| lt | lte | gt | gte
| add | sub | mul
| div | rem
| perm_div | magic_wand
| union | intersection | setminus
| concat
| membership
| subset
}
eq = { "==" }
neq = { "!=" }
implies = { "==>" }
or = { "||" }
and = { "&&" }
iff = { "<==>" }
lt = { "<" }
lte = { "<=" }
gt = { ">" }
gte = { ">=" }
add = { "+" }
sub = { "-" }
mul = { "*" }
div = { "\\\\" }
rem = { "\\%" }
perm_div = { "\\/" }
magic_wand = { "--*" }
union = { "union" }
intersection = { "intersection" }
setminus = { "setminus" }
concat = { "++" }
membership = { "in" }
subset = { "subset" }
// unop ::=
//   "!" |            // boolean negation
//   "+" | "-"        // integer and permission
unop = { "!" | "+" | "-" }

formal_arg = { ident~ ":"~ type }
