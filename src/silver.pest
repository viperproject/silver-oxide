WHITESPACE = {" " | "\t" | NEWLINE }
COMMENT = _{"//"~ (!"\n" ~ ANY)* | "/*"~ (!"*/"~ANY)*~"*/" }
char = { 'a'..'z' | 'A'..'Z' | "$" | "_"}
num = { '0'..'9' }

integer = @{num+}

// Identifiers
ident = @{ char ~ (char | num | "'" )* }

// Types
// type ::=
// "Int" | "Bool" | "Perm" | "Ref" | "Rational" | // primitive types
// "Seq" "[" type "]" |                           // sequence type
// "Set" "[" type "]" |                           // set type
// "Multiset" "[" type "]" |                      // multiset type
// ident [ "[" type^,* "]" ]                      // [instance of a generic] domain type

type = {
       | kw_Int
       | kw_Bool
       | kw_Perm
       | kw_Ref
       | kw_Rational
       | "Seq" ~ "[" ~ type ~ "]"
       | "Set" ~ "[" ~ type ~ "]"
       | "Multiset" ~ "[" ~ type ~ "]"
       | "Map"~ "[" ~ type ~","~ type ~ "]"
       |  type_constr// ???? domain type
     }

type_constr = { ident ~ ("[" ~ type ~ ("," ~ type)* ~ "]")? }

kw_Int = @{"Int"~ !ASCII_ALPHANUMERIC }
kw_Bool = @{"Bool"~ !ASCII_ALPHANUMERIC }
kw_Perm = @{"Perm"~ !ASCII_ALPHANUMERIC }
kw_Ref = @{"Ref"~ !ASCII_ALPHANUMERIC }
kw_Rational = @{"Rational"~ !ASCII_ALPHANUMERIC }

// predicate-access ::=
//   ident "(" exp^,* ")"         // predicate access
predicate_access = _{ func_app }

// field-access ::=
//   exp "." ident |              // field access
field_access = { exp_atom~postfix+ }
// loc-access ::=
//   field-access | predicate-access
loc_access = {field_access | predicate_access }

res_acc = { magic_wand_exp | loc_access }
// acc-exp ::=
//    "acc" "(" loc-access ["," exp ]")" //access
                                // default is write
acc_exp = { "acc"~"("~loc_access~(","~exp)?~")" | predicate_access }
// trigger ::=
//   "{" exp^,* "}"  // a trigger for a quantification
trigger = {
       "{"~(exp~(","~exp)*)?~"}"
}
// seq-op-exp ::=
//   exp "[" exp "]"          |  // sequence lookup
//   exp "[" ".." exp "]"     |  // take n first elements
//   exp "[" exp ".." "]"     |  // drop n first elements
//   exp "[" exp ".." exp "]" |  // take and drop
//   exp "[" exp ":=" exp "]" |  // update sequence at
seq_op_exp = {
       exp ~ "[" ~ exp ~ "]" |
       exp ~ "[" ~ ".." ~ exp ~ "]" |
       exp ~ "[" ~ exp ~ ".." ~ "]" |
       exp ~ "[" ~ exp ~ ".." ~ exp ~ "]" |
       exp ~ "[" ~ exp ~ ":=" ~ exp ~ "]"
}

// set-constructor-exp ::=
//   "Set" "[" type "]" "(" ")"             | // empty set
//   "Set" "(" exp^,* ")"                   | // explicit set
//   "Multiset" "[" type "]" "(" ")"        | // empty multiset
//   "Multiset" "(" exp^,* ")"              | // explicit multiset
set_constructor_exp = {
       "Set" ~ "[" ~ type ~ "]" ~ "(" ~ ")" |
       "Set" ~ "(" ~ exp ~ ("," ~ exp)* ~ ")" |
       "Multiset" ~ "[" ~ type ~ "]" ~ "(" ~ ")" |
       "Multiset" ~ "(" ~ exp ~ ("," ~ exp)* ~ ")"
}

// seq-constructor-exp ::=
//   "Seq[" type "]()"     | // the empty sequence
//   "Seq(" exp^,* ")"     | // explicit sequence (must not be empty)
//   "[" exp ".." exp ")"    // half-open range of numbers
seq_constructor_exp = {
       "Seq[" ~ type ~ "]()" |
       "Seq(" ~ exp ~ ("," ~ exp)* ~ ")" |
       "[" ~ exp ~ ".." ~ exp ~ ")"
}

map_constructor_exp = {
       "Map"~ "["~ type ~ "," ~ type ~ "]"~"("~")"
}

// forperm-exp ::=
//     "forperm" "[" ident^,* "]" ident "::" exp
forperm_exp = {
       "forperm"~formal_arg_list_ne~"["~res_acc~"]"~"::"~exp
}

id_ty = _{ formal_arg }
formal_arg_list_ne = { id_ty~(","~id_ty)* }
formal_arg_list = { (id_ty~(","~id_ty)*)? }

// let-in-exp ::=
//     "let" ident "==" "(" exp ")" "in" exp
let_in_exp = {
       "let" ~ ident ~ "==" ~ "(" ~ exp ~ ")" ~ "in" ~ exp
}
// magic-wand-exp ::=
//     exp // except that it must not be <==> or ==>
magic_wand_exp = _{ // TODO: Ban <==> or ==>
       exp
}
// exp ::=
//   "true"  | "false" |          // boolean literal
//   integer |                    // integer literal
//   "null"   |                   // null literal
//   "result" |                   // result literal in
//                                //  function postconditions
//   ident    |                   // local variable read

//   "(" exp ")" |

//   unop exp |                  // unary expression
//   exp binop exp |             // binary expression
//   exp "?" exp ":" exp |       // conditional expression

//   "old" "(" exp ")"           // old expression
//   "[" ident "]" "(" exp ")"   // labeled old expression
//   "lhs" "(" exp ")"           // apply old expression

//   "none"     |             // no permission literal
//   "write"    |             // full permission literal
//   "epsilon"  |             // epsilon permission literal
//   "wildcard" |             // wildcard permission

//   "perm" "(" loc-access ")" | // current permission
//                               //  of given location

//   acc-exp  |                   // accessibility predicate

//   ident "(" exp^,* ")" |                // [domain] function application
//   "(" ident "(" exp^,* ")" ":" type ")" // typed function application

//   field-access         |  // field read
//   predicate-access     |  // predicate access

//   "[" exp "," exp "]" |        // inhale exhale expression
//   "unfolding" acc-exp "in" exp | // unfolding expression
//   "folding" acc-exp "in" exp
//   "applying" ( "(" magic-wand-exp ")" | ident ) "in" exp
//   "packaging" ( "(" magic-wand-exp ")" | ident ) "in" exp

//   // quantification
//   "forall" formal-arg^,* "::" trigger^,* exp |
//   "exists" formal-arg^,* "::" exp |

//   seq-constructor-exp      |
//   set-constructor-exp      |

//   seq-op-exp  |
//   "|" exp "|" |                // length of a sequence; or set/multiset cardinality

//   let-in-exp  |
//   forperm-exp

// TODO(xavier): Fix left recursion in seq ops and field access
// TOD(xavier): Fix precedence parsing of prefix operators
exp_atom = {
       "true"~!ASCII_ALPHA
      | "false"~!ASCII_ALPHA
      | integer
      | "null"~!ASCII_ALPHA
      | "result"~!ASCII_ALPHA
      | "("~ exp ~ ")"
      | unop~exp
      | "old"~("["~ident~"]")?~"("~exp~")"
      | "["~ident~"]"~"("~exp~")"
      | "lhs"~"("~exp~")"
      | "none"~!ASCII_ALPHA
      | "write"~!ASCII_ALPHA
      | "epsilon"~!ASCII_ALPHA
      | "wildcard"~!ASCII_ALPHA
      | "perm"~"("~loc_access~")"
      | "("~ident~"("~(exp~(","~exp)*)?~")"~":"~type~")"
      // | field_access
       | "["~exp~","~exp~"]"
       | kw_unfolding~acc_exp~"in"~exp
       | "folding"~acc_exp~"in"~exp
       | "applying"~"("~magic_wand_exp~")"~"in"~exp
       | "packaging"~"("~magic_wand_exp~")"~"in"~exp
       | "forall"~formal_arg_list_ne~"::"~trigger*~exp
       | "exists"~formal_arg_list_ne~"::"~trigger*~exp
       | seq_constructor_exp
       | set_constructor_exp
       | map_constructor_exp
       // | seq_op_exp
       | "|"~exp~"|"
       | let_in_exp
       | forperm_exp
       | func_app
       | predicate_access
       | acc_exp
       | ident
}

kw_unfolding = @{ "unfolding"~!ASCII_ALPHA }

func_app = {ident~func_app_args}
func_app_args = { "("~ ")" | "("~exp~(","~exp)*~")" }

// exp = { exp_atom~(binop_plus~exp_atom)*}
exp = {exp_atom~postfix*~(binop_plus~exp_atom~postfix*)* }
// binop_plus = _{ "+" }
binop_plus = _{ binop | "?"~exp~":" }

postfix = _ {
       | "."~ident
       | "[" ~ seq_op ~ "]"
}
seq_op = {
       ".."~exp | exp ~ (".."~exp? | ":="~exp)?
}

single_exp = _{ SOI~exp~EOI }

// binop ::=
//   "==" | "!=" |                  // equality operators
//   "==>" | "||" | "&&" |"<==>" |  // boolean operators
//   "<" | "<=" | ">" | ">=" |      // ordering
//                                  //  (integers and permissions)
//   "+" | "-" | "*" |              // arithmetic operators
//                                  //  (integers and permissions)
//                                  // also int*permission
//   "\\" | "\%" |                  // arithmetic division
//                                  //  and modulo
//   "\/" |                         // permission division
//                                  //  (of two integers)
//   "--*" |                        // magic wand

//   "union" | "intersection" | "setminus"  //set operators
//   "++"  |           // sequence concatenation
//   "in"  |           // set/multiset/sequence membership
//   "subset"          // subset relation
binop = {
| implies | or | and | iff
| eq | neq
| lte | gte | lt  | gt
| perm_div | magic_wand
| add | sub | mul
| div | rem
| union | intersection | setminus
| concat
| membership
| subset
}
eq = { "==" }
neq = { "!=" }
implies = { "==>" }
or = { "||" }
and = { "&&" }
iff = { "<==>" }
lt = { "<" }
lte = { "<=" }
gt = { ">" }
gte = { ">=" }
add = { "+" }
sub = { "-" }
mul = { "*" }
div = { "\\" }
rem = { "%" }
perm_div = { "/" }
magic_wand = { "--*" }
union = @{ "union"~!ASCII_ALPHA }
intersection = @{ "intersection"~!ASCII_ALPHA }
setminus = @{ "setminus"~!ASCII_ALPHA }
concat = { "++" }
membership = @{ "in"~!ASCII_ALPHA }
subset = @{ "subset"~!ASCII_ALPHA }
// unop ::=
//   "!" |            // boolean negation
//   "+" | "-"        // integer and permission
unop = { "!" | "+" | "-" }

// // Declarations
// sil-program ::=
//   (
//     import    |
//     define    |
//     domain    |
//     field     |
//     function  |
//     predicate |
//     method
//   )*
sil_program = _{ SOI~(declaration)*~EOI }
declaration = {import | define | domain | field | function | predicate | method | adt }

// import ::=
//     "import" relative-path
import = { "import"~("<"~relative_path~">" | "\""~relative_path~"\"") }

  // def relativeFilePath[$: P]: P[PRawString] = ((CharIn("~.").? ~~ (CharIn("/").? ~~ CharIn(".", "A-Z", "a-z", "0-9", "_\\- \n\t")).rep(1)).! map PRawString.apply).pos

relative_path = { ("~" | ".")? ~ ("/"? ~ ("." | ASCII_ALPHANUMERIC | "_" | "\\" | "-" | WHITESPACE))+ }
// relative-path ::=
//     \A(?:[\w-]+\/?)+\z
// relative_path = { (ident~"/")*~ident }
// relative_path = @{ ((ASCII_ALPHANUMERIC | "-")+~"/")*~(ASCII_ALPHANUMERIC | "-")+ ~"/"?}
// define ::=
//     "define" identifier [ "(" parameter^,* ")" ] expression-or-block
define = { "define"~ident~parameters?~expression_or_block }

parameters = { "("~ ")" | "("~parameter~(","~parameter)*~")" }
// parameter ::= ident
parameter = { ident }

// expression-or-block ::=
//     exp |
//     block
expression_or_block = { exp | block }

// domain ::=
//   "domain" domain-name "{"
//     domain-function*
//     axiom*
//   "}"
domain = { "domain"~domain_name~"{"~(domain_function | axiom)*~"}" }

// domain-name ::=
//   ident |
//   ident "[" ident^,* "]"  //e.g. Seq[T]
domain_name = { ident~"["~ident~(","~ident)*~"]" | ident }

// domain-function ::=
//   ["unique"] function-signature [";"]
domain_function = { "unique"?~function_signature~";"? }

// function-signature ::=
//   "function" ident formal-args ":" type
function_signature = { "function"~ident~formal_args~":"~type }

// axiom ::=
//   "axiom" ident "{" exp "}" [";"]
axiom = { "axiom"~ident?~"{"~exp~"}"~";"? }

// field ::=
//   "field" ident ":" type [";"]
field = { "field"~ident~":"~type~(";"?) }


adt = { "adt" ~ type_constr ~ adt_variants }

adt_variants = {
       "{" ~ "}"
       | "{" ~ (ident~formal_args)* ~ "}"
}

// function ::=
//   function-signature
//     precondition*
//     postcondition*
//   "{" exp "}" // Semicolon not permitted
function = { function_signature~(precondition | decreases)*~(postcondition | decreases)*~("{"~exp~"}")? }

decreases = { "decreases"~decrease_exp }

one_decreases = {SOI~decreases~EOI}

decrease_exp = { &("requires" | "ensures") | "*" | "_"~("if"~exp)? | ( exp~(","~exp)*~("if"~exp)?)? }
// precondition ::=
//   "requires" exp
precondition = { "requires"~exp~";"? }

// postcondition ::=
//   "ensures" exp
postcondition = { "ensures"~exp~";"? }

// invariant ::=
//   "invariant" exp
invariant = { "invariant"~exp }

// predicate ::=
//   "predicate" ident formal-args ["{" exp "}"] // Semicolon not permitted
predicate = { "predicate"~ident~formal_args~("{"~exp~"}")? }

// method ::=
//   "method" ident formal-args [formal-returns]
//     precondition*
//     postcondition*
//   [ block ]
method = { "method"~ident~formal_args~(formal_returns)?~(precondition | decreases)*~(postcondition | decreases)*~(block)?  }
// formal-args ::=
//   "(" formal-arg^,* ")"
formal_args = { "("~(formal_arg~(","~formal_arg)*)?~")" }

// formal-arg ::=
//   ident ":" type
formal_arg = { ident~":"~type | type }

// formal-returns ::=
//   "returns" formal-args
formal_returns = { "returns"~formal_args }

// // Statements
// block ::=
//   "{" statement-with-optional-semicolon* "}"
block = { "{"~statement_with_optional_semicolon*~"}" }

// statement-with-optional-semicolon ::=
//   stmt [";"]
statement_with_optional_semicolon = { stmt~";"? }

// stmt ::=
//   // local variable declaration with an optional initial value
//   "var" ident  ":" type [":=" exp] |

//   // local definition
//   define |

//   // local variable assignment
//   ident ":=" exp |

//   // field assignment
//   field-access ":=" exp |

//   // object creation (all fields)
//   ident ":=" "new(*)" |

//   // object creation (specified fields)
//   ident ":=" "new(" ident^,* ")" |

//   "assert" exp |
//   "assume" exp |
//   "inhale" exp |
//   "exhale" exp |
//   "fold"   acc-exp |
//   "unfold" acc-exp |

//   "goto" ident | // goto statement
//   "label ident | // a goto label

//   if-statement           |
//   while-statement        |
//   call-statement         |
//   fresh-statement        |
//   wand-statement         |
//   constraining-block     |

//   // an arbitrary block of statements
//   block

stmt = {
       kw_var~(ident~":"~type~(","~ident~":"~type)*)~(":="~exp)? |
       define |
       kw_assert~exp |
       kw_assume~exp |
       kw_inhale~exp |
       kw_exhale~exp |
       kw_fold~acc_exp |
       kw_unfold~acc_exp |
       kw_goto~ident |
       kw_label~ident~invariant_list |
       kw_havoc~loc_access |
       kw_quasihavoc~(exp~"==>")?~exp |
       kw_quasihavocall~formal_arg_list_ne~"::"~(exp~"==>")?~exp |
       while_statement |
       if_statement |
       wand_statement |
       ident~":="~"new"~"(" ~"*"~")" |
       ident~":="~"new("~ident~(","~ident)*~")" |
       call_statement |
       fresh_statement |
       constraining_block |
       block
}



kw_var    = @{ "var" ~ !ASCII_ALPHA }
kw_assert = @{ "assert" ~ !ASCII_ALPHA }
kw_assume = @{ "assume" ~ !ASCII_ALPHA }
kw_inhale = @{ "inhale" ~ !ASCII_ALPHA }
kw_exhale = @{ "exhale" ~ !ASCII_ALPHA }
kw_fold   = @{ "fold"   ~ !ASCII_ALPHA }
kw_unfold = @{ "unfold" ~ !ASCII_ALPHA }
kw_goto   = @{ "goto"   ~ !ASCII_ALPHA }
kw_label  = @{ "label"  ~ !ASCII_ALPHA }
kw_havoc  = @{ "havoc"  ~ !ASCII_ALPHA }
kw_quasihavoc = @{ "quasihavoc" ~ !ASCII_ALPHA }
kw_quasihavocall = @{ "quasihavocall" ~ !ASCII_ALPHA }

single_stmt = { SOI~stmt~EOI }

// if-statement ::=
//   "if" "(" exp ")"
//     block
//   ("elsif" "(" exp ")"
//     block
//   )*            // any number of elseif branches
//   ["else"
//     block
//   ]             // optional else branch
if_statement = { "if"~"("~exp~")"~block~("elsif"~"("~exp~")"~block)*~("else"~block)? }

// while-statement ::=
//   "while" "(" exp ")"
//     invariant*
//     block
while_statement = { "while"~"("~exp~")"~invariant_list~block }

invariant_list = { ((invariant | decreases)~";"?)*}

// call-statement ::= // method call [with return target]
//   [ident^,* :=] ident "(" exp^,* ")"

assign_target = { field_access | func_app  | ident }

call_statement = { assign_target~((","~assign_target)*~":="~exp)? }

one_call = {SOI~call_statement~EOI}
// fresh-statement ::=
//   "fresh" ident^,*
fresh_statement = { "fresh"~ident~(","~ident)* }

// wand-statement ::=
//   "wand" ident ":=" exp |
//   "package" magic-wand-exp |
//   "apply" magic-wand-exp
wand_statement = { "wand"~ident~":"~exp |
       "package"~magic_wand_exp~block? |
       "apply"~magic_wand_exp
}

// constraining-block ::=
//   "constraining" "(" ident^,* ")"
//     block
constraining_block = { "constraining"~"("~ident~(","~ident)*~")"~block }